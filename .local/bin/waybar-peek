#!/usr/bin/env bash

set -euo pipefail

duration="${1:-3}"

if ! [[ "$duration" =~ ^[0-9]+$ ]]; then
    printf 'Usage: %s [duration_seconds]\n' "$0" >&2
    exit 1
fi

runtime_dir="${XDG_RUNTIME_DIR:-}"
state_dir="/tmp"

if [[ -n "$runtime_dir" ]]; then
    if tmpfile="$(mktemp -p "$runtime_dir" waybar-state.XXXX 2>/dev/null)"; then
        state_dir="$runtime_dir"
        rm -f "$tmpfile"
    fi
fi

state_file="${state_dir}/waybar.visibility"

current_state() {
    if [[ -f "$state_file" ]]; then
        cat "$state_file"
        return
    fi

    printf 'hidden\n'
}

set_state() {
    printf '%s\n' "$1" >"$state_file"
}

ensure_waybar_running() {
    if pgrep -x waybar >/dev/null 2>&1; then
        return
    fi

    if command -v setsid >/dev/null 2>&1; then
        setsid -f waybar >/dev/null 2>&1 || true
    else
        nohup waybar >/dev/null 2>&1 &
    fi

    # Allow the compositor to register the bar before toggling visibility.
    sleep 0.2
    set_state "hidden"
}

toggle_waybar() {
    pkill -SIGUSR1 waybar >/dev/null 2>&1 || true
}

show_waybar() {
    toggle_waybar
    set_state "visible"
}

hide_waybar() {
    toggle_waybar
    set_state "hidden"
}

finalize() {
    if [[ "$made_visible" != "1" ]]; then
        return
    fi

    if [[ "$(current_state)" == "visible" ]]; then
        hide_waybar
    fi
}

ensure_waybar_running
initial_state="$(current_state)"
made_visible=0

if [[ "$initial_state" != "visible" ]]; then
    made_visible=1
    show_waybar
fi

trap finalize EXIT

sleep "$duration"
